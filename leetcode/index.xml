<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcodes on sin-coder</title>
    <link>https://sin-coder.github.io/leetcode/</link>
    <description>Recent content in Leetcodes on sin-coder</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 11 Dec 2019 14:01:10 +0800</lastBuildDate>
    
	<atom:link href="https://sin-coder.github.io/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>使用堆解决常见TOPK问题</title>
      <link>https://sin-coder.github.io/leetcode/topkheap/</link>
      <pubDate>Wed, 11 Dec 2019 14:01:10 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/leetcode/topkheap/</guid>
      <description>使用堆解决常见的TOK问题  关于常见的TOPK问题，都可以使用堆这种数据结构来巧妙的解决，除了去统计最大的或者最小的K个元素
 之外，还有一些变形的问题，比如统计出现频率TOPK的问题，这种问题一般需要进行排序。下面列出leetcode
上一些典型的例题：
 数组中的第K最大的元素
 根据字符出现的频率进行排序（堆排序）
 前K个高频元素 leetcode 347
 前K个高频单词 leetcode 692
   理解了堆的特点后，解决这些问题并不难，但是我们要熟悉一些堆的基本操作，比如如何生成一个堆、对
 堆中的元素进行排序等。此外，在满足复杂度要求的前提下，如何写出更加简练的代码也是一个关注点。毫无
疑问的是在对数据的处理上，python比Java有着先天的优势，在代码编写方面会更加简洁，下面是例题
一、前K个高频元素  给定一个非空的整数数组，返回其中出现频率前 *k* 高的元素
对于这种求TOPK频率的问题，与以往的求最大的K个元素不同，我们需要用哈希表来存放每个元素及其出
 现的频率，再用堆这种数据结构去按照升序排列，代码如下：
//构建一个哈希表用来存放每个元素及其出现的频率 private HashMap&amp;lt;Integer,Integer&amp;gt; map = new HashMap(); //构建一个小顶堆，并且该堆要对map中的元素出现的频率进行排序 private PriorityQueue&amp;lt;Integer&amp;gt; heap = new PriorityQueue&amp;lt;&amp;gt;((n1,n2) -&amp;gt; map.get(n1) map.get(n2)); //返回的列表 private List&amp;lt;Integer&amp;gt; topK = new LinkedList(); public List&amp;lt;Integer&amp;gt; topKFrequent(int[] nums, int k) { //先统计每个元素及其出现的频率，当然还有更简单的写法，请看拓展内容 for(int n : nums){ if(map.</description>
    </item>
    
    <item>
      <title>贪心算法集锦</title>
      <link>https://sin-coder.github.io/leetcode/greedy/</link>
      <pubDate>Mon, 02 Dec 2019 22:26:15 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/leetcode/greedy/</guid>
      <description>贪心算法解题总结 一、引例  某天你在超市购物后，总共消费了782元，这时假设你有1元、5元、10元、20元、100元和200元的钞票
 无穷多张，那么最少需要多少张钞票足够支付？
 直觉告诉我们：要尽可能多地使用面值较大的钞票，其实这就是一种贪心的思想
 二、贪心算法简介  由引例我们已经大概了解了什么是贪心，在这儿对它下个定义：贪心算法是指在对问题求解时，总是做
 出在当前看来是最好的选择；也就是说不从整体最优上加以考虑，它所做出的是在某种意义上的局部最优解
 贪心算法不是对所有的问题都能得到整体的最优解，关键是贪心策略的选择，具体的贪心策略中某个状
 态以前的过程不会影响以后的状态，只与当前的状态有关
三、Leetcode典型例题 1.455分发饼干  (1) 题目描述
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每
 个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺
寸 sj 。如果 sj &amp;gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足
越多数量的孩子，并输出这个最大数值。一个小朋友最多能拥有一块饼干
 (2)解题思想
根据让更多的孩子得到满足这个目标，可以分析出如下贪心规律：
  某块饼干不能满足某个孩子的胃口，则它也一定不能满足胃口更大的孩子
 某个孩子的胃口可以用更小的饼干来满足，则没有必要用更大的饼干满足，更大的饼干留给胃口更大的孩子
 孩子的胃口越小，则其更容易被满足，所以优先从胃口小的孩子尝试
   (3)算法思路
  按照胃口大小和饼干大小对两个数组进行从小到大的排序
 按照从小到大的顺序用饼干来尝试是否可以满足某个孩子的胃口，每个饼干只尝试一次，如能够满足，接着
   用下一块饼干继续尝试能否满足下一个孩子的胃口；否则，抛弃该饼干，用下一块饼干继续尝试满足当前
的孩子。直到没有更多的孩子或者没有更多的饼干，算法结束
(4)代码实现</description>
    </item>
    
    <item>
      <title>从尾到头打印链表</title>
      <link>https://sin-coder.github.io/leetcode/printlistreverse/</link>
      <pubDate>Fri, 15 Nov 2019 14:01:10 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/leetcode/printlistreverse/</guid>
      <description>反转链表专题 No.1 问题描述  输入一个链表，从尾到头的顺序返回一个ArrayList
 解题思路 1.使用递归法 //1.解法一 public ArrayList&amp;lt;Integer&amp;gt; printListReverse(ListNode listnode){ ArrayList&amp;lt;Integer&amp;gt; arrayList = new ArrayList&amp;lt;Integer&amp;gt;(); if(listnode != null){ arrayList.addAll(printListReverse(listnode.next)); arrayList.add(listnode.val); } return arrayList; } //分析：时间复杂度为O（n）,相当于将每个元素均遍历了一遍 //空间复杂度为O（n^2）,创建的列表的合计元素个数1+2+3+4+n-1 //拓展内容：ArrayList中的addAll(Collection&amp;lt;? extends E&amp;gt; c) 方法 按照指定collection容器返回元素的 //顺序将所有的元素添加到列表的尾部  2.使用栈（推荐解法） //Java实现 public ArrayList&amp;lt;Integer&amp;gt; printListReverse(ListNode listnode){ ArrayDeque&amp;lt;Integer&amp;gt; stack = ArrayDeque&amp;lt;Integer&amp;gt;(); while(listnode != null){ stack.addFirst(listnode.val); listnode = listnode.next; } ArrayList&amp;lt;Integer&amp;gt; arrayList = new ArrayList&amp;lt;Integer&amp;gt;(); while(stack.pollFirst()) arrayList.add(stack.pollFirst()) return arrayList; } //Java中推荐使用ArrayDeque来实现一个栈 //当压栈时，调用addFirst()方法; 出栈时调用pollFirst()方法 //分析：时间复杂度O(n)，空间复杂度也是O（n）  #基于Python的实现 class Solution: def printListReverse(self,listnode): if not listnode: return [] result = [] while listnode: result.</description>
    </item>
    
    <item>
      <title>环形链表</title>
      <link>https://sin-coder.github.io/leetcode/circlelist/</link>
      <pubDate>Fri, 15 Nov 2019 14:01:10 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/leetcode/circlelist/</guid>
      <description>环形链表专题 一、问题1  给定一个链表，判断一个链表中是否有环
 1.算法思路  （1）判断是否存在重复节点
通过检查一个节点此前是否被访问来判断是否为环形链表，可以使用哈希表来存储访问过的节点
（2）快慢指针
通过快慢指针遍历链表，慢指针每次移动一步，而快指针每次移动两步；如果链表中不存在环，最终快
 指针将会最先达到尾部，此时返回Fasle即可；如果链表中存在环，最终快慢指针一定会相遇
2.代码实现 //元素判重法 public boolean hasCycle(ListNode head) { Set&amp;lt;ListNode&amp;gt; visited = new HashSet&amp;lt;ListNode&amp;gt;(); while (head != null) { if (visited.contains(head)) { return true; } else { visited.add(head); } head = head.next; } return false; } //分析，时间复杂度是O（n），对链表中的每个元素最多访问一次，向哈希表中添加一个元素为O(1) //空间复杂度为O（n）,最多将链表中的所有元素均添加到哈希表中  //快慢指针法 public boolean hasCycle(ListNode head) { if (head == null || head.next == null) { return false; } ListNode slow = head; ListNode fast = head.</description>
    </item>
    
  </channel>
</rss>