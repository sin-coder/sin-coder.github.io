<!doctype html>
<html lang="en-us">
  <head>
    <title>Python中的面向对象 // sin-coder</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.59.1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="csuyzz" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://sin-coder.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Python中的面向对象"/>
<meta name="twitter:description" content="Python中的面向对象  说起面向对象，大家都不陌生，常用的Java就是一门面向对象的语言，但是很少人会觉得Python是一门
 面向对象的语言，习惯使用Python的人更会觉得它有点像面向过程的语言，毕竟那流程化的操作让人觉得
是从哪里冒出来的对象啊，今天是时候为Python平反了，Python和Java都是面向对象的语言
 但是我们所说的面向对象通常指的是编程的一种设计思想，更加准确的说应该是Python和Java都是支持
 面向对象的语言，而且Python和Java都不是纯碎的面向对象，当然我们也不必过于纠结什么是纯碎。这篇
讲解一些Python中面向对象的一些特性
一、面向对象的主要特性  在面向对象编程中，函数和变量被进一步的封装成类，类是程序的基本元素，类和类的实例是面向对象
 的核心概念，面向对象的主要编程框架如下：
 导入各种外部库
 设计各种全局变量
 决定你要的类
 给每个类提供完整的一组操作
 明确的使用继承来表现不同类的特点
 根据需要决定是否要写一个mian函数作为程序入口
   面向对象中一些基础的概念是多态、继承、封装、抽象、类、对象、实例、方法、重载，下面对一些主要
 的概念稍作解释
 类变量：所有实例公有的变量，类变量定义在类中，但是在方法体之外
 实例变量：是实例本身所拥有的变量，每个实例变量在内存都是不一样的
 静态方法：不需要实例化就可以由类指向的方法
 类方法：类方法是将类本身作为对象进行操作的方法
 重写：从父类继承的方法不能满足子类的需求，这个过程称为override
 封装：将内部实现包装起来，对外透明
 继承：子类继承父类的变量和方法
 多态：根据对象类型的不同以不同的方式进行处理
  二、类与对象 1.类和对象的创建  Python中类和对象的创建是这样进行的
 class test: classVar = &quot;Test&quot; #类变量 def __init__(self,para1,para2): #理解为构造函数 self.para1 = para1 self."/>

    <meta property="og:title" content="Python中的面向对象" />
<meta property="og:description" content="Python中的面向对象  说起面向对象，大家都不陌生，常用的Java就是一门面向对象的语言，但是很少人会觉得Python是一门
 面向对象的语言，习惯使用Python的人更会觉得它有点像面向过程的语言，毕竟那流程化的操作让人觉得
是从哪里冒出来的对象啊，今天是时候为Python平反了，Python和Java都是面向对象的语言
 但是我们所说的面向对象通常指的是编程的一种设计思想，更加准确的说应该是Python和Java都是支持
 面向对象的语言，而且Python和Java都不是纯碎的面向对象，当然我们也不必过于纠结什么是纯碎。这篇
讲解一些Python中面向对象的一些特性
一、面向对象的主要特性  在面向对象编程中，函数和变量被进一步的封装成类，类是程序的基本元素，类和类的实例是面向对象
 的核心概念，面向对象的主要编程框架如下：
 导入各种外部库
 设计各种全局变量
 决定你要的类
 给每个类提供完整的一组操作
 明确的使用继承来表现不同类的特点
 根据需要决定是否要写一个mian函数作为程序入口
   面向对象中一些基础的概念是多态、继承、封装、抽象、类、对象、实例、方法、重载，下面对一些主要
 的概念稍作解释
 类变量：所有实例公有的变量，类变量定义在类中，但是在方法体之外
 实例变量：是实例本身所拥有的变量，每个实例变量在内存都是不一样的
 静态方法：不需要实例化就可以由类指向的方法
 类方法：类方法是将类本身作为对象进行操作的方法
 重写：从父类继承的方法不能满足子类的需求，这个过程称为override
 封装：将内部实现包装起来，对外透明
 继承：子类继承父类的变量和方法
 多态：根据对象类型的不同以不同的方式进行处理
  二、类与对象 1.类和对象的创建  Python中类和对象的创建是这样进行的
 class test: classVar = &quot;Test&quot; #类变量 def __init__(self,para1,para2): #理解为构造函数 self.para1 = para1 self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sin-coder.github.io/program/oop/" />
<meta property="article:published_time" content="2019-12-20T21:14:28+08:00" />
<meta property="article:modified_time" content="2019-12-20T21:14:28+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://sin-coder.github.io"><img class="app-header-avatar" src="/cat.jpg" alt="csuyzz" /></a>
      <h1>sin-coder</h1>
      <p>I always remember that &#39;Talk is cheap,show me the code&#39;</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/sin-coder" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="mailto:csuyzz@foxmail.com" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-mail">
  <title>mail</title>
  <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>
</svg></a>
        
          <a target="_blank" href="https://cn.linkedin.com/in/csuyzz" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin">
  <title>linkedin</title>
  <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>
</svg></a>
        
          <a target="_blank" href="https://twitter.com/csuyzz1" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg></a>
        
      </div>
      <h3><a href="/" title="首页">首页</a></h3>
      <h3><a href="/category/content/" title="首页">分类目录</a></h3>
      <h3><a href="/personal/introduce/" title="首页">个人简介</a></h3>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Python中的面向对象</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Dec 20, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div><div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
          <a class="tag" href="https://sin-coder.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><a class="tag" href="https://sin-coder.github.io/tags/python/">Python</a></div></div>
    </header>
    <div class="post-content">
      

<h2 id="python中的面向对象">Python中的面向对象</h2>

<hr />

<blockquote>
<p>说起面向对象，大家都不陌生，常用的Java就是一门面向对象的语言，但是很少人会觉得Python是一门</p>
</blockquote>

<p>面向对象的语言，习惯使用Python的人更会觉得它有点像面向过程的语言，毕竟那流程化的操作让人觉得</p>

<p>是从哪里冒出来的对象啊，今天是时候为Python平反了，Python和Java都是面向对象的语言</p>

<blockquote>
<p>但是我们所说的面向对象通常指的是编程的一种设计思想，更加准确的说应该是Python和Java都是支持</p>
</blockquote>

<p>面向对象的语言，而且Python和Java都不是纯碎的面向对象，当然我们也不必过于纠结什么是纯碎。这篇</p>

<p>讲解一些Python中面向对象的一些特性</p>

<h3 id="一-面向对象的主要特性">一、面向对象的主要特性</h3>

<blockquote>
<p>在面向对象编程中，函数和变量被进一步的封装成类，类是程序的基本元素，类和类的实例是面向对象</p>
</blockquote>

<p>的核心概念，面向对象的主要编程框架如下：</p>

<ul>
<li><p>导入各种外部库</p></li>

<li><p>设计各种全局变量</p></li>

<li><p>决定你要的类</p></li>

<li><p>给每个类提供完整的一组操作</p></li>

<li><p>明确的使用继承来表现不同类的特点</p></li>

<li><p>根据需要决定是否要写一个mian函数作为程序入口</p></li>
</ul>

<blockquote>
<p>面向对象中一些基础的概念是多态、继承、封装、抽象、类、对象、实例、方法、重载，下面对一些主要</p>
</blockquote>

<p>的概念稍作解释</p>

<ul>
<li><p>类变量：所有实例公有的变量，类变量定义在类中，但是在方法体之外</p></li>

<li><p>实例变量：是实例本身所拥有的变量，每个实例变量在内存都是不一样的</p></li>

<li><p>静态方法：不需要实例化就可以由类指向的方法</p></li>

<li><p>类方法：类方法是将类本身作为对象进行操作的方法</p></li>

<li><p>重写：从父类继承的方法不能满足子类的需求，这个过程称为override</p></li>

<li><p>封装：将内部实现包装起来，对外透明</p></li>

<li><p>继承：子类继承父类的变量和方法</p></li>

<li><p>多态：根据对象类型的不同以不同的方式进行处理</p></li>
</ul>

<h3 id="二-类与对象">二、类与对象</h3>

<h4 id="1-类和对象的创建">1.类和对象的创建</h4>

<blockquote>
<p>Python中类和对象的创建是这样进行的</p>
</blockquote>

<pre><code class="language-python">class test:
    classVar = &quot;Test&quot;  #类变量
    def __init__(self,para1,para2):   #理解为构造函数
        self.para1 = para1
        self.para2 = para2
    def fun1(self):              #类中的方法
        pass
    def fun2(self):
        pass
</code></pre>

<h4 id="2-方法的调用">2.方法的调用</h4>

<blockquote>
<p>在类中方法主要有四类：实例方法、类方法、静态方法、属性方法</p>
</blockquote>

<ul>
<li><p>实例方法：就是每个实例可以调用的方法，就是最普通的方法，一般会有一个self参数</p></li>

<li><p>类方法： 只能访问类变量，不能访问实例变量，使用装饰器@classmethod表示</p></li>

<li><p>属性方法：将一个方法变成一个静态属性，不同加小括号就可以直接调用的，使用装饰器@property表示</p></li>

<li><p>静态方法：静态方法没有默认的参数，它将实例方法参数中的self去掉，然后在方法定义上加上@staticmethod，</p></li>
</ul>

<blockquote>
<p>就成为了静态方法，它属于类，与实例无关，建议只用类名.静态方法的调用方式。经常有一些跟类有关系</p>

<p>的功能但是运行时又不需要实例和类参与的情况下需要用到静态方法，比如更改环镜变量或者修改其他类的</p>

<p>属性等能用到静态方法</p>
</blockquote>

<pre><code class="language-python">#静态方法使用示例
class Test:
    @staticmethod   #定义了一个静态方法
    def fun():
        pass
Test.fun()    #使用类直接去调用静态方法

#类方法使用示例
class Person(object):
    def __init__(self,name):
        self.name = name
    @classmethod
    def printMsg(self):
        print(self.name)    #self.name这个变量是实例化这个类是传进去的，类方法不能访问
    
class Person(object):
    name = &quot;yzz&quot;
    def __init__(self,name):
        self.name = name
    @classmethod
    def printMsg(self):
        print(self.name)    #类方法可以访问类变量
        
 #属性方法使用实例
class Person(object):
    def __init__(self,name):
        self.name = name
    @property
    def printMsg(self):
        print(&quot;Hello World&quot;)
per = Person(&quot;yzz&quot;)
per.eat                  #按照调用属性的方式调用
</code></pre>

<h4 id="3-成员修饰符">3.成员修饰符</h4>

<blockquote>
<p>Python中的类只有私有成员和公有成员两种，并且python中没有关键字去修饰成员，默认python中</p>
</blockquote>

<p>所有的成员都是公有成员，私有成员是以两个下划线开头来标识的；私有成员不允许直接访问，只能通</p>

<p>过内部方法去访问，私有成员也不允许被继承</p>

<pre><code class="language-python">class Test:
    __age = 10 #私有变量
    def __init__(self,name,salary):
        self.name = name
        self.__salary = salary #私有变量
    def printName(self):
        print(self.name)
    #如果要在类中调用私有变量，应该使用类方法
    @classmethod
    def printMsg(cls):
        print(cls.__age,self.__salary)
</code></pre>

<h3 id="三-类的主要特性">三、类的主要特性</h3>

<h4 id="1-继承">1.继承</h4>

<blockquote>
<p>在Python中的类可以继承多个类，但是Java只能继承一个类；Python中如果父类和子类都重新定义了</p>
</blockquote>

<p>构造方法init()，在进行子类实例化的时候，子类的构造方法不会自动调用父类的构造方法，必须在子类中</p>

<p>显式地调用</p>

<pre><code class="language-python">#单继承
class DerivedClassName(BaseClassName1):
    pass
#基类定义在另一个模块中时
class DerivedClassName(modname.BaseClassName):
    pass

#多继承
class DerivedClassName(Base1,Base2,Base3):
    pass
#当父类中有相同方法名，但在子类中使用时未指定，Python会从左至右搜索父类是否包含该方法
</code></pre>

<h4 id="2-方法重写">2.方法重写</h4>

<blockquote>
<p>当Python中的父类方法功能不能满足时，子类中可以进行重写</p>
</blockquote>

<pre><code class="language-python">class Parent:
    def printMsg(self):
        print(&quot;我是父类方法&quot;)
class Child(Parent):
    def printMsg(self):
        print(&quot;我是子类方法&quot;)
#super()函数就是调用父类方法的一个方法
</code></pre>

<h4 id="3-反射和自省">3.反射和自省</h4>

<blockquote>
<p>Python中反射和自省的实现是通过一些魔法方法来实现的：hasattr、getattr、setattr、delattr四个内置函</p>
</blockquote>

<p>数来实现的，这些方法在类和对象以及其他模块中用的都是比较多的，其中key都是字符串</p>

<ul>
<li><p>hasattr(key)： 返回的是一个bool值，判断某个成员或者属性是否存在于类或者对象中</p></li>

<li><p>getattr(key，default = xxx)：获取类或者对象的成员或者属性，如果不存在抛出AttributrError异常，如果</p></li>
</ul>

<blockquote>
<p>定义了default那么没有属性的时候会返回默认值</p>
</blockquote>

<ul>
<li><p>setattr(key, value)：加入有这个属性就更新这个属性，如果没有就添加这个属性并赋值value</p></li>

<li><p>delattr(key):删除某个属性</p>

<pre><code class="language-python">class Test:
def __init__(self,name,age):
    self.name = name
    self.age = age
def show(self):
    return self.name.self.age 
obj = Test(&quot;yzz&quot;,18)
print(getattr(obj,&quot;name&quot;)) #获取属性值
set(obj,&quot;k1&quot;,&quot;v1&quot;)  #添加属性
print(hasattr(obj,&quot;k1&quot;))  #查看是否存在这个属性
delattr(obj,&quot;k1&quot;)       #删除这个属性
</code></pre></li>
</ul>

<blockquote>
<p>反射和自省能够直接访问以及修改运行的类和对象的成员和属性，实际用例：</p>
</blockquote>

<pre><code class="language-python">import test
addr = input(&quot;请输入URL：&quot;)
if addr in test.__dict__:
    getattr(test,addr)()
else:
    print(&quot;404&quot;)
</code></pre>

<h3 id="四-单例模式">四、单例模式</h3>

<blockquote>
<p>在面向对象中的单例模式就是一个类只有一个对象，所有的操作都是通过这个对象来完成，示例如下</p>
</blockquote>

<pre><code class="language-python">class Test:
    __v = None
    @classmethod
    def getinstance(cls):
        if cls.__v:
            return cls.__v
        else:
            cls.__v = Test()
            return cls.__v
        
obj1 = Test.getinstance()
obj2 = Test.getinstance()
obj3 = Test.getinstance()
#三个对象的内存地址都是一样的，这样可以节省资源
</code></pre>

<blockquote>
<p>比如在数据库连接池时使用单例模式，只创建一个类的对象供其他程序调用；Web服务请求中也是使用</p>
</blockquote>

<p>这个单例模式</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>
<script src="https://utteranc.es/client.js"
        repo="sin-coder/hugocomments"
        issue-term="pathname"
        theme="github-dark"  
        crossorigin="anonymous"
        async>
</script>

    </main>
  </body>
</html>
