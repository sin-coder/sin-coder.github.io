<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构 on sin-coder</title>
    <link>https://sin-coder.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
    <description>Recent content in 数据结构 on sin-coder</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 21 Dec 2019 14:01:10 +0800</lastBuildDate>
    
	<atom:link href="https://sin-coder.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>数据结构学习心得</title>
      <link>https://sin-coder.github.io/datastructure/summay/</link>
      <pubDate>Sat, 21 Dec 2019 14:01:10 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/datastructure/summay/</guid>
      <description>数据结构学习心得  学习数据结构和算法也有段时间了， 在此记录自己学习的过程，以及心得和体会
一开始就是从
我不是专门搞竞赛的，学习数据结构只是为了面试和提高自己的逻辑思维能力，确实很多厉害的算法知识我也是不会的，只能解决常规的问题
数据结构最高层的抽象便只有数组和链表
嗯？那队列、栈、哈希表、堆、树、图都去哪了呢
数组和链表是数据结构的结构基础，其他的都是属于上层建筑。哪些多样化的数据结构，究其源头，都是在
 链表或者数组上的不同操作而已
 比如队列和栈这两种数据结构既可以使用链表、也可以使用数组实现。用数组实现，就要处理不断扩容的
 问题；用链表实现，就没有这个问题，但是需要避免更多的存储节点指针；图也有两种的表示方法，邻接表
就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，但是一般比较耗费空间，邻接表比较节省空间，
但是处理效率要比邻接矩阵慢很多
 散列表就是通过散列函数将键映射到一个大数组中，而对于解决散列冲突的方法，拉链法使用链表，操作比
 较简单，但需要空间。线性探查法需要使用数组，连续寻址，比较省空间，但是操作复杂
 树用数组实现就是堆，因为堆是一个完全的二叉树，父子节点之间有对应的关系，方便使用数组进行存储。
 其他种类的树因为没有完全二叉树那种特殊的关系，所以不便于使用数组进行存储，只能使用链表，在链表树的
基础上又设计出许多巧妙的树，如二叉搜索树、AVL树、红黑树、B树、B+树等等
 数据结构的操作，无非就是遍历和访问，具体就是增删查改。不同的数据结构应用的场景不同，在每种
 场景下要尽可能地进行高效的增删查改。遍历和访问无外乎就两种形式，线性和非线性的，线性的就是for/while
为代表，非线性的就是以递归为代表
数组的遍历框架都是线性的：
public void traverse(int[] arr){ for(int i = 0;i &amp;lt; arr.length;i++){ //访问每一个arr[i] } }  二叉树的遍历框架，典型的非线性递归遍历结构：
public void traverse(TreeNode root){ traverse(root.left); traverse(root.right) }   这两个框架都可以根据自己的需求进行改进
 链表的遍历框架既可以是线性的，也可以是非线性的
public void traverse(ListNode head){ while(head != null){ //访问head.val head = head.</description>
    </item>
    
    <item>
      <title>贪心算法集锦</title>
      <link>https://sin-coder.github.io/leetcode/greedy/</link>
      <pubDate>Mon, 02 Dec 2019 22:26:15 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/leetcode/greedy/</guid>
      <description>贪心算法解题总结 一、引例  某天你在超市购物后，总共消费了782元，这时假设你有1元、5元、10元、20元、100元和200元的钞票
 无穷多张，那么最少需要多少张钞票足够支付？
 直觉告诉我们：要尽可能多地使用面值较大的钞票，其实这就是一种贪心的思想
 二、贪心算法简介  由引例我们已经大概了解了什么是贪心，在这儿对它下个定义：贪心算法是指在对问题求解时，总是做
 出在当前看来是最好的选择；也就是说不从整体最优上加以考虑，它所做出的是在某种意义上的局部最优解
 贪心算法不是对所有的问题都能得到整体的最优解，关键是贪心策略的选择，具体的贪心策略中某个状
 态以前的过程不会影响以后的状态，只与当前的状态有关
三、Leetcode典型例题 1.455分发饼干  (1) 题目描述
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每
 个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺
寸 sj 。如果 sj &amp;gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足
越多数量的孩子，并输出这个最大数值。一个小朋友最多能拥有一块饼干
 (2)解题思想
根据让更多的孩子得到满足这个目标，可以分析出如下贪心规律：
  某块饼干不能满足某个孩子的胃口，则它也一定不能满足胃口更大的孩子
 某个孩子的胃口可以用更小的饼干来满足，则没有必要用更大的饼干满足，更大的饼干留给胃口更大的孩子
 孩子的胃口越小，则其更容易被满足，所以优先从胃口小的孩子尝试
   (3)算法思路
  按照胃口大小和饼干大小对两个数组进行从小到大的排序
 按照从小到大的顺序用饼干来尝试是否可以满足某个孩子的胃口，每个饼干只尝试一次，如能够满足，接着
   用下一块饼干继续尝试能否满足下一个孩子的胃口；否则，抛弃该饼干，用下一块饼干继续尝试满足当前
的孩子。直到没有更多的孩子或者没有更多的饼干，算法结束
(4)代码实现</description>
    </item>
    
    <item>
      <title>BFS &amp; DFS算法</title>
      <link>https://sin-coder.github.io/datastructure/bfs-dfs/</link>
      <pubDate>Thu, 28 Nov 2019 17:01:10 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/datastructure/bfs-dfs/</guid>
      <description>深度优先和广度优先算法详解 一、DFS 和 BFS 算法概述 1.什么是DFS和BFS？  DFS （Depth-First-Search）,称为深度优先搜索；BFS（Breadth-First-Search），称为广度优先搜索。
 这二者都是在树和图的遍历中应用非常广泛的算法，那么再来看下遍历的定义：从初始点出发，按照某种
搜索方法对树或图中的每个节点均做一次且仅做一次的访问，访问具体节点所做的操作依赖于具体的问题。
 在树的遍历算法中，我们经常会看到前序遍历、中序遍历、后续遍历、层序遍历等方法，其实前序遍历
 就是深度优先搜索的一种实现，层序遍历就是对广度优先搜索的一种实现。树也可以看做是一种特殊的图，
树和图的遍历主要的区别就是树有根节点（指定的），而图需要我们自身指定开始遍历的节点。
2.DFS和BFS算法的核心思想  BFS和DFS都是图的遍历方法。它们具有一些共性的问题，比如都要避免节点的重复访问，具体的实践
 中可以设置一个访问数组，数组中的每个元素代表一个节点，当节点被访问后数组中对应的元素赋一个特定
的值进行标记即可
 DFS的搜索过程是这样的：
  先访问初始节点V
 从V未被访问的邻接点中选取一个W，从W出发进行DFS
 重复上述步骤即可
   BFS的搜索过程是这样的：
  先访问图的初始节点V
 依次访问V节点的所有邻接节点V1，V2，V3&amp;hellip;
 按照V1，V2，V3被访问的次序依次访问与它们相邻接的未被访问的节点
 重复上述过程
  3.DFS和BFS算法效率分析  DFS和BFS的时间复杂度只与数据的底层存储结构相关，而与搜索的路径无关。当使用邻接矩阵存
 储时，对于每一个被访问的节点，都要循环检测矩阵中的整整一行（n个元素），时间复杂度为O（n^2）
当使用邻接表来存储时，有2e个表节点，但只需要扫描e个节点即可完成遍历，加上访问n个头节点的
时间，时间复杂度为O（n+e）
 DFS和BFS算法的空间复杂度相同，都是借用了堆栈或队列，为O（n）。递归在本质上也属于栈
 二、DFS 和BFS 的算法实现  图在底层都是以邻接表或者邻接矩阵的方式来存储的，在Java、C++都可以使用表或者矩阵来进行定义
 的，Python中可以使用字典来进行定义。解决图的BFS问题就是利用队列的先进先出的思想，队列可以保存
图中未遍历的节点；解决图的DFS问题是利用栈这种数据结构，递归和非递归的实现本质上都是先进后出。
1.DFS的算法实现  假设有这样一张图：
  （1）Python的实现</description>
    </item>
    
    <item>
      <title>数据结构之容器</title>
      <link>https://sin-coder.github.io/datastructure/datastructure/container/</link>
      <pubDate>Thu, 28 Nov 2019 17:01:10 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/datastructure/datastructure/container/</guid>
      <description>一、概述 1.什么是数据结构中的容器？  容器是一种把多个元素组织在一起的数据结构，也可以理解为一种可以包含其他类型对象作为元素的
 的对象。容器是仅仅用来存放数据的，本身没有取出元素这种能力，大多数情况下是通过可迭代对象来
操作容器
 容器这种数据结构在各种编程语言中都有相应的实现，比如我们经常会比较熟悉的C++的标准模板库
 （Standard Template Library，STL）、Java的集合框架（Java Collections Framework，JCF）、而在
Python中更是将容器类型的数据结构作为其基本数据类型、Go语言也有内建的容器和相应的标准库，
本篇博客便是在总结各种容器使用及原理的基础上，对Java、Python中相同的类型的容器做一个横向的
对比，以便于日后的总结和复习
2.Java集合框架简介  （1）泛型的机制
Java中的容器就是可以容纳其他Java对象的对象，且Java容器中只能存放对象，对于一些基本的数据
 类型（比如int、long、float、double等），需要将其包装成对象类型之后（Interger、Long、Float、Double
等）才能放到容器里，很多时候拆包装和解包装使能够自动完成的
 Java容器能够容纳任何类型的对象，表面上是通过泛型机制完成的。事实上，所有容器的内部存放的都
 是Object类的对象，所有的对象都是Object类型的子类。泛型机制只是简化了编程，由编译器自动帮助我们
完成了强制类型的转换而已，示例代码如下
ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;(); //参数化类型 list.add(new String(&amp;quot;csuyzz&amp;quot;)); String name = list,get(0); //容器中存放的Object类的对象隐式转换成为String类型的对象   此外，Java里的对象都在堆上，且对象只能通过引用（reference）来访问，容器里存放的其实是对
 象的引用而不是对象的本身
 （2）接口和实现（Interfaces and Implementations）
在Java 的集合框架中共定义了14种容器的接口，关系图如下所示，Map接口没有继承自Collection的
 接口，因为Map接口是关联式的容器而不是集合，但也可以从Map转换到Coolection；Stack已经被Deque
所取代

 接口的实现如下表所示
 ImplementationsHash TableResizable ArrayBalanced TreeLinked ListHash Table + Linked ListInterfacesSetHashSetTreeSetLinkedHashSetListArrayListLinkedListDequeArrayDequeLinkedListMapHashMapTreeMapLinkedHashMap &amp;gt; (3) 迭代器</description>
    </item>
    
    <item>
      <title>从尾到头打印链表</title>
      <link>https://sin-coder.github.io/leetcode/printlistreverse/</link>
      <pubDate>Fri, 15 Nov 2019 14:01:10 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/leetcode/printlistreverse/</guid>
      <description>反转链表专题 No.1 问题描述  输入一个链表，从尾到头的顺序返回一个ArrayList
 解题思路 1.使用递归法 //1.解法一 public ArrayList&amp;lt;Integer&amp;gt; printListReverse(ListNode listnode){ ArrayList&amp;lt;Integer&amp;gt; arrayList = new ArrayList&amp;lt;Integer&amp;gt;(); if(listnode != null){ arrayList.addAll(printListReverse(listnode.next)); arrayList.add(listnode.val); } return arrayList; } //分析：时间复杂度为O（n）,相当于将每个元素均遍历了一遍 //空间复杂度为O（n^2）,创建的列表的合计元素个数1+2+3+4+n-1 //拓展内容：ArrayList中的addAll(Collection&amp;lt;? extends E&amp;gt; c) 方法 按照指定collection容器返回元素的 //顺序将所有的元素添加到列表的尾部  2.使用栈（推荐解法） //Java实现 public ArrayList&amp;lt;Integer&amp;gt; printListReverse(ListNode listnode){ ArrayDeque&amp;lt;Integer&amp;gt; stack = ArrayDeque&amp;lt;Integer&amp;gt;(); while(listnode != null){ stack.addFirst(listnode.val); listnode = listnode.next; } ArrayList&amp;lt;Integer&amp;gt; arrayList = new ArrayList&amp;lt;Integer&amp;gt;(); while(stack.pollFirst()) arrayList.add(stack.pollFirst()) return arrayList; } //Java中推荐使用ArrayDeque来实现一个栈 //当压栈时，调用addFirst()方法; 出栈时调用pollFirst()方法 //分析：时间复杂度O(n)，空间复杂度也是O（n）  #基于Python的实现 class Solution: def printListReverse(self,listnode): if not listnode: return [] result = [] while listnode: result.</description>
    </item>
    
    <item>
      <title>常见数据结构的定义</title>
      <link>https://sin-coder.github.io/datastructure/defindatastructure/</link>
      <pubDate>Fri, 15 Nov 2019 14:01:10 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/datastructure/defindatastructure/</guid>
      <description>常见数据结构的定义 一、单链表（singly-linked list） 1.Java public class ListNode{ int val; ListNode next; ListNode(int x) { val = x; next = null; } }  2.Python class ListNode: def __init__(self,x): self.val = x self.next = Node  3.C struct ListNode{ int val; struct ListNode *next; };  4.Go type ListNode struct{ Val int Next *ListNode }  二、二叉树（Binary Tree Node） 1.Java //Definition for a binary tree node public class TreeNode{ int val; TreeNode left; TreeNode right; TreeNode(int x){val = x;} }  2.</description>
    </item>
    
    <item>
      <title>环形链表</title>
      <link>https://sin-coder.github.io/leetcode/circlelist/</link>
      <pubDate>Fri, 15 Nov 2019 14:01:10 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/leetcode/circlelist/</guid>
      <description>环形链表专题 一、问题1  给定一个链表，判断一个链表中是否有环
 1.算法思路  （1）判断是否存在重复节点
通过检查一个节点此前是否被访问来判断是否为环形链表，可以使用哈希表来存储访问过的节点
（2）快慢指针
通过快慢指针遍历链表，慢指针每次移动一步，而快指针每次移动两步；如果链表中不存在环，最终快
 指针将会最先达到尾部，此时返回Fasle即可；如果链表中存在环，最终快慢指针一定会相遇
2.代码实现 //元素判重法 public boolean hasCycle(ListNode head) { Set&amp;lt;ListNode&amp;gt; visited = new HashSet&amp;lt;ListNode&amp;gt;(); while (head != null) { if (visited.contains(head)) { return true; } else { visited.add(head); } head = head.next; } return false; } //分析，时间复杂度是O（n），对链表中的每个元素最多访问一次，向哈希表中添加一个元素为O(1) //空间复杂度为O（n）,最多将链表中的所有元素均添加到哈希表中  //快慢指针法 public boolean hasCycle(ListNode head) { if (head == null || head.next == null) { return false; } ListNode slow = head; ListNode fast = head.</description>
    </item>
    
  </channel>
</rss>