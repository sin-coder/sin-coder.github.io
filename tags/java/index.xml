<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on sin-coder</title>
    <link>https://sin-coder.github.io/tags/java/</link>
    <description>Recent content in Java on sin-coder</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 03 Dec 2019 21:14:28 +0800</lastBuildDate>
    
	<atom:link href="https://sin-coder.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java和Python中如何使用大顶堆</title>
      <link>https://sin-coder.github.io/program/javapqueue/</link>
      <pubDate>Tue, 03 Dec 2019 21:14:28 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/program/javapqueue/</guid>
      <description>Java和Python中如何使用大顶堆  在数据结构之容器的那篇文章中，我们对于优先队列即堆这种数据结构的底层实现进行了剖析，在实际的
 应用中我们不必自己去实现一个堆，主流的编程语言都提供了相关的集合模块，比如Java中的PriorityQueue
类，Python中的heapq模块。但是这两种语言中实现的堆都是小顶堆（根节点的元素小于左右节点元素的值），
当需要使用大顶堆时该如何解决呢？比如典型的最大的K个元素需要用小顶堆解决，但是最小的K个元素不就
是需要使用一个大顶堆来解决了吗！
 具体的解决方案如下：
 一、通用的方法: 取反  通用的解决方法就是跟语言没有关系的解法，想要构造一个大顶堆，只要保证根节点大于左右节点即可，
 所以我们可以将数据取成相反数再添加到小顶堆中去，取出时再对数据进行取反即可实现大顶堆的效果
二、针对Java的方法  优先队列中存放的是基本数据类型的包装类（Integer、Long）或者自定义的包装类。对于基本数据类型
 的包装器类，优先队列中元素默认排列顺序是升序排列的，也就是说是小顶堆，但是既然是默认的就可以进
行更改。此外，对于自定义的类来说，需要自己定义比较器，比如：
//自定义比较器，降序排列 public static Comparator&amp;lt;Integer&amp;gt; cmp = new Comparator&amp;lt;Integer&amp;gt;(){ public int compare(Integer e1,Integer e2){ return e2 - e1; } } //声明对象时 Queue&amp;lt;Integer&amp;gt; pqueue = new PriorityQueue&amp;lt;Integer&amp;gt;(); //不使用比较器，默认升序排列，即小顶堆 Queue&amp;lt;Integer&amp;gt; pqueue = new PriorityQueue&amp;lt;Integer&amp;gt;(cmp); //使用比较器，降序排列，即为大顶堆 //比较器升降序的声明 Comparator&amp;lt;Object&amp;gt; cmp = new Comparator&amp;lt;Object&amp;gt;(){ public int compare(Object o1,Object o2){ return o1 - o2 //升序 return o2 - o1 //降序 } }   所以在实际解决问题的过程中如果需要使用大顶堆可以这样声明</description>
    </item>
    
    <item>
      <title>数据结构之容器</title>
      <link>https://sin-coder.github.io/datastructure/container/</link>
      <pubDate>Thu, 28 Nov 2019 17:01:10 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/datastructure/container/</guid>
      <description>一、概述 1.什么是数据结构中的容器？  容器是一种把多个元素组织在一起的数据结构，也可以理解为一种可以包含其他类型对象作为元素的
 的对象。容器是仅仅用来存放数据的，本身没有取出元素这种能力，大多数情况下是通过可迭代对象来
操作容器
 容器这种数据结构在各种编程语言中都有相应的实现，比如我们经常会比较熟悉的C++的标准模板库
 （Standard Template Library，STL）、Java的集合框架（Java Collections Framework，JCF）、而在
Python中更是将容器类型的数据结构作为其基本数据类型、Go语言也有内建的容器和相应的标准库，
本篇博客便是在总结各种容器使用及原理的基础上，对Java、Python中相同的类型的容器做一个横向的
对比，以便于日后的总结和复习
2.Java集合框架简介  （1）泛型的机制
Java中的容器就是可以容纳其他Java对象的对象，且Java容器中只能存放对象，对于一些基本的数据
 类型（比如int、long、float、double等），需要将其包装成对象类型之后（Interger、Long、Float、Double
等）才能放到容器里，很多时候拆包装和解包装使能够自动完成的
 Java容器能够容纳任何类型的对象，表面上是通过泛型机制完成的。事实上，所有容器的内部存放的都
 是Object类的对象，所有的对象都是Object类型的子类。泛型机制只是简化了编程，由编译器自动帮助我们
完成了强制类型的转换而已，示例代码如下
ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;(); //参数化类型 list.add(new String(&amp;quot;csuyzz&amp;quot;)); String name = list,get(0); //容器中存放的Object类的对象隐式转换成为String类型的对象   此外，Java里的对象都在堆上，且对象只能通过引用（reference）来访问，容器里存放的其实是对
 象的引用而不是对象的本身
 （2）接口和实现（Interfaces and Implementations）
在Java 的集合框架中共定义了14种容器的接口，关系图如下所示，Map接口没有继承自Collection的
 接口，因为Map接口是关联式的容器而不是集合，但也可以从Map转换到Coolection；Stack已经被Deque
所取代

 接口的实现如下表所示
 ImplementationsHash TableResizable ArrayBalanced TreeLinked ListHash Table + Linked ListInterfacesSetHashSetTreeSetLinkedHashSetListArrayListLinkedListDequeArrayDequeLinkedListMapHashMapTreeMapLinkedHashMap &amp;gt; (3) 迭代器</description>
    </item>
    
    <item>
      <title>常见数据结构的定义</title>
      <link>https://sin-coder.github.io/datastructure/defindatastructure/</link>
      <pubDate>Fri, 15 Nov 2019 14:01:10 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/datastructure/defindatastructure/</guid>
      <description>常见数据结构的定义 一、链表（以singly-linked list为例） 1.Java public class ListNode{ int val; ListNode next; //如果是双向链表，则会为left or right ListNode(int x) { val = x; next = null; } }  2.Python class ListNode: def __init__(self,x): self.val = x self.next = Node  3.C struct ListNode{ int val; struct ListNode *next; };  4.Go type ListNode struct{ Val int Next *ListNode }  二、二叉树（Binary Tree Node） 1.Java //Definition for a binary tree node public class TreeNode{ int val; TreeNode left; TreeNode right; TreeNode(int x){val = x;} }  2.</description>
    </item>
    
  </channel>
</rss>