<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on sin-coder</title>
    <link>https://sin-coder.github.io/post/</link>
    <description>Recent content in Posts on sin-coder</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 28 Jan 2020 01:22:22 +0800</lastBuildDate>
    
	<atom:link href="https://sin-coder.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>消息队列学习笔记</title>
      <link>https://sin-coder.github.io/post/messagequ/</link>
      <pubDate>Tue, 28 Jan 2020 01:22:22 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/post/messagequ/</guid>
      <description>消息队列学习笔记 [TOC]
一、消息队列简介 1.概述 消息是指在应用间传送数据，消息可以只包含文本字符串、或者包含嵌入式对象
消息队列是一种应用程序对应用程序的通信方法。它是是生产者-消费者模型的一个典型的代表，一端往消息队列中不断地写入消息，而另一端则可以读取队列中的消息。这样发布者和接受者都不知道对方的存在。消息队列也可以简单理解为：把要传输的数据放在队列中
2.消息获取模式 消费者获取消息时有两种模式，点对点模式和发布订阅模式
（1）点对点模式 点对点模型通常是一个基于拉取或者轮询的消息传递模型，这种模型从队列中请求消息，而不是将消息推送到客户端。这种模式的特点是一对一，发送到队列的消息被一个且只有一个接受者接收处理，即使有多个消息监听者也是如此，消息被收到后即可清除
点对点模式的优点是队列发送数据和客户端接收数据的速度是相匹配的，缺点是客户端需要实时监控队列中是否有消息存在
（2）发布/订阅模式 发布订阅模型是一个基于推送的消息传送模型，该种模型下订阅者有临时订阅者和持久订阅者之分，临时订阅者只在主动监听主题时才接收消息；而持久订阅者则监听主题的所有消息，即使当前订阅者不可用，处于离线状态。这种模型的特点是一对多，数据生产后，推送给所有的订阅者
发布/订阅模式的优点是客户端不需要实时监控队列中是否有消息存在，缺点是队列发送数据的速度无法和多个客户端接收数据的速度是相匹配
二、消息队列作用  解耦：客户端与客户端之间或者客户端和服务器 之间不需要直接连接，而是通过中间件来进行连接。  ​ 而且允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束
 冗余：消息队列可以对数据进行持久化（本地备份）直到它们已经被处理，这样就规避了数据的丢失。许多消息  ​ 队列均采用“插入-获取-删除”的范式，即在把一个消息从队列中删除之前，需要你的系统明确的指出该消息
​ 已经被处理完毕
 峰值处理：可以组建集群，进而增大消息入队和处理的频率。在访问量剧增的情况下，应用仍然需要继续发挥作  ​ 用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大
​ 的浪费。消息队列基于它的可扩展性使其本身可以顶住突发的访问压力，而不会因为突发的超负荷的请求
​ 而使系统完全崩溃
 数据可恢复：当系统的一部分组件失效时，不会影响到整个的系统 。消息队列降低了进程间的耦合度，即使一个  ​ 处理消息的进程挂掉，加入队列中的消息仍可在系统恢复后被处理
 顺序保证：消息队列本来就是排好序的，并且也能够保证数据按照特定的顺序来进行处理
 缓冲：消息队列可以控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况
 异步：用户可以将消息放入队列，不立即处理，仅在需要的时候再去处理，有关同步异步等问题请查看此篇博客
  三、常用消息队列简介 ​ 常见的消息队列有ActiveMQ、RabbitMQ、ZeroMQ、Kafka、MetaMQ、RocketMQ等几种
1.Kafka  开源消息系统，基于Scala写成
 完全的分布式消息队列，Kafka对消息保存时根据Topic进行归类；Kafka集群由多个实例组成，每个实例
  （Server）称为一个broker
 集群和消费者均依赖于Zookeeper集群保存一些meta信息，来保证系统的可用性
 系统在O(1)的系统开销下进行消息持久化
 可以自动实现负载均衡
  2.</description>
    </item>
    
    <item>
      <title>分布式系统学习笔记</title>
      <link>https://sin-coder.github.io/post/distri/</link>
      <pubDate>Mon, 27 Jan 2020 00:44:13 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/post/distri/</guid>
      <description>一、分布式系统概述 1.什么是分布式系统？ ​ 分布式系统主要由网络、分布式存储与分布式计算等部分构成的，分布式存储侧重于数据的读写存取及一致性等方面，而分布式计算则侧重于资源、任务的编排和调度
2.分布式系统的特点 ​ 没有强制性的中心控制、次级单位具有自治的特质、次级单位之间彼此高度链接、点对点之间的影响通过网络形成了非线性的因果关系
3.传统架构面临的难题: 系统的扩展 ​ 高并发的访问要求我们的后端系统架构弹性且可扩展
​ 三维扩展：
​ X轴扩展：水平复制，即在负载均衡服务器后增加多个Web服务器，
​ Y轴扩展：对数据库的扩展，即进行分库分表，分库是将关系紧密的表放在一台数据库服务器上，分表是因为一张表的数据太多，需要将一张表的数据通过hash放在不同的数据库服务器上
​ Z轴扩展：业务方向的扩展，才能将巨型应用分解为一组不同的服务，将应用进一步分解为微服务
​ 4.CAP定理
​ 在分布式系统中，系统的一致性(Consistency)、可用性（Availability）、分区容忍性(Partion tolerance)。这三者不能同时保证，由于网络通信的不确定性，分区的容忍性是必须要保证的，而且互联网应用比企业级应用更加偏向于保持可用性，通常用最终一致性代替传统事务的ACID强一致性
​
二、分布式计算 1.概述 ​ 分布式计算核心的思路就是系统架构无单点，让整个系统可以扩展。分布式计算环境下的节点分为有状态存储节点和无状态存储节点。
​ 无状态存储节点，不存储数据，请求分发可以采取很简单的随机算法或者是轮询的算法就可以了，如果需要增加机器，则只需要把对应的运算代码部署到一些机器上然后启动起来，引导流量到那些机器即可实现动态的扩展了。简单来说就是某台机器承担了某种角色后，能够快速的广播给需要这个角色提供服务的机器。
​ 而针对有状态节点，扩容难度较大，因为每台Server中均有数据，所以请求分发的算法不能够随机或者轮询，一般来说常见算法就是哈希或者使用Tree来做一层映射，增加机器时需要经历一个复杂的数据迁移过程&amp;mdash;&amp;mdash;》自动化扩容和迁移的工具
2.数据处理的发展过程
GFS&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-》HDFS
BigTable&amp;mdash;&amp;mdash;&amp;ndash;》HBase
​ MapReduce&amp;mdash;-》MapReduce
​ （Hadoop技术栈）
MapReduce(离线处理)&amp;mdash;&amp;ndash;》Spark(高性能批处理技术)&amp;mdash;&amp;mdash;》Storm(流处理)&amp;mdash;-》Flink
3.批处理（Batch Processing）与流处理（Stream Processing） 主要区别：每一条数据在到达时是被处理的（流处理），还是作为一组新数据的一部分稍后进行处理（批处理）
批处理：在批处理中新到达的数据元素被收集到一个组中，整个组在未来的时间内进行处理。至于何时处理每个组可以选择多种方式来确定，可以基于预定的时间间隔（如每隔5分钟）、或者在某些触发的条件下（只要包含5个元素/拥有超过1MB的数据）。传统的数据仓库和Hadoop就是专注于批处理的。批处理示意图如下：
缺点：具有延迟性、新数据的到达与该数据的处理之间的延迟将取决于直到下一批处理窗口的时间
流处理：流处理设计的目的是为了在数据到达时对其进行响应，这就要求它们实现一个由事件驱动的体系架构，也可以说是在系统的内部工作流在接收到数据后立即连续监视新数据和调度处理。
应用：Flink、Beam等都支持“流式处理优先，将批处理视为流式处理的特殊情况”，但是流式处理器的出现并没有让批处
​ 理器变得过时。因为纯流式处理系统在批处理工作负载时其实是非常慢的。
​ Apache Beam: 这样统一的API通常会根据数据是持续的（无界）、还是固定的（有界）将工作负载委托给不同的
​ 运行机制
​ Flink: 提供的流式API，可以处理有界或者无界的场景，同时任然提供了单独的DataSet API用于批处理
​
三、分布式调度 1.概述
经典资源调度器（Yarn）&amp;mdash;&amp;ndash;》数据调度（Data Placement）、资源任务调度（Resource Management）、计算调度（Application Manager）、本地微（自治）调度
2.资源调度</description>
    </item>
    
    <item>
      <title>基于Hugo框架搭建个人博客</title>
      <link>https://sin-coder.github.io/post/hugo/</link>
      <pubDate>Tue, 07 Jan 2020 14:08:20 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/post/hugo/</guid>
      <description>[TOC]
关键词：Hugo 、Git、Github、域名解析 概述 1.Hugo简介  Hugo是基于Go语言开发的静态网站生成器，简单、易用、快速部署，主要用于构建个人博客
 2.Git简介  Git是目前主流的分布式版本控制工具，有关Git的使用请查看Git的来龙去脉这篇文章
 3.Github简介  Github是在外网环境下的一个代码托管库，有关Github的介绍请查看开始玩起Github这篇文章
 具体过程 1.准备工作  下载Git并安装、配置环境变量  完成后在终端执行&amp;rdquo;git&amp;rdquo;命令来测试是否安装成功，有关git的安装请看Git的来龙去脉
 下载Hugo并安装、配置环境变量  完成后在终端执行&amp;rdquo;hugo version&amp;rdquo;命令来测试是否安装成功，终端提示如下信息表示安装成功
C:\Users\Administrator&amp;gt;hugo version Hugo Static Site Generator v0.59.1-D5DAB232 windows/amd64 BuildDate: 2019-10-31T15:22:43Z  Hugo最好安装在英文目录下
下载时可能由于网络问题失败，附上Hugo、Git、主题m10c的下载包链接: 下载链接
 注册Github官网（已有账号请忽略）  2.生成个人站点 （1）在终端执行命令 C:\Users\Administrator&amp;gt;hugo new site E:\hugo\Sites\myblog  出现以下提示信息表示创建成功：
C:\Users\Administrator&amp;gt;hugo new site E:\hugo\Sites\myblog Congratulations! Your new Hugo site is created in E:\hugo\Sites\myblog. Just a few more steps and you&#39;re ready to go: 1.</description>
    </item>
    
    <item>
      <title>Go语言学习总结（二）</title>
      <link>https://sin-coder.github.io/post/golang/</link>
      <pubDate>Mon, 27 Jan 2020 01:01:45 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/post/golang/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Mapreduce</title>
      <link>https://sin-coder.github.io/post/mapreduce/</link>
      <pubDate>Mon, 27 Jan 2020 00:54:15 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/post/mapreduce/</guid>
      <description>1.什么是Map? 什么是Reduce?
Map是拆解 Reduce是组装 本治就是分治法
Input &amp;ndash;&amp;gt; Split&amp;ndash;&amp;gt;Map&amp;mdash;&amp;gt;Shuffle（组装）&amp;mdash;&amp;gt;Reduce &amp;mdash;-&amp;gt;Finalize（高度并行的）
实现代码：
MapReduce如何实现统计单词出现的次数的
Map（string key, string value） #key : the id of a line #value: the content of the line for each word in value: OutputTemp(word,1) # Reduce 的过程 Reduce(string key,list valueList) #key : the name of a word #valueList: the appearance of this world int sum = 0 for value in valueList: sum+=value OutputFinal(key,sum)  MapReduce 如何实现倒排索引的？
MapReduce的整体结构？
总结：Map就是一个disassemble Reduce 就是一个assemble</description>
    </item>
    
    <item>
      <title>Bigtable</title>
      <link>https://sin-coder.github.io/post/bigtable/</link>
      <pubDate>Mon, 27 Jan 2020 00:53:53 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/post/bigtable/</guid>
      <description>1.如何在文件内进行快速查询？
关键点： 从File 到 Table Table = a list of sorted 
2.如何保存一个很大的表？
关键点： A table = a list of tables (小表)
A tablet = a list of sorted 
使用MetaData的形式保存每一个小表的位置
3.如何保存一个超大的表？
关键点：A table = a list of tablets （小表）
​ A tablet = a list of SSTables （小小表）
​ A SSTables = a list of sorted 
4.如何向表中写数据？
关键点：通过写入memTable（内存表）来加速
A tablet = memTable + a list of SSTables
5.内存表过大怎么办？如何避免内存丢失数据？</description>
    </item>
    
    <item>
      <title>Google File System</title>
      <link>https://sin-coder.github.io/post/gfs/</link>
      <pubDate>Mon, 27 Jan 2020 00:53:42 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/post/gfs/</guid>
      <description>Google File System 一、概述 Google的三篇论文：Google File System 、BigTable 、MapReduce的发表彻底拉开了云计算时代的序幕，同时这三篇论文也是想要入门云计算的学习人员必读的。最近读了这三篇论文，再参考了一些资料后写下自己的总结
HDFS 、HBase 、MapReduce
 GFS BigTable MapReducd  Google系统整体的架构图如下
GFS系统的优点：高可用性、自动负载均衡
系统的结构：文件系统（GFS）、数据模型（Bigtable）、算法（MapReduce）、应用
在本篇文章中我们着重去描述GFS
二、GFS系统的设计 1.设计思路
​ （1）组件失效是一种常态，而不是意外；因此持续的监控、错误的侦测、灾难冗余等机制必须集成在GFS
​ （2）存储的文件非常巨大，基本上为TB级的，I/O操作和Block、Chunk的尺寸都需要规划
​ （3）对文件的修改以在文件尾部追加数据为主，数据的追加对系统性能有重要的影响
​ （4）应用程序和文件系统的API协同设计可以大幅度提高系统的灵活性
2.系统的工作负载分析
3.GFS系统架构
三、系统工作原理 设计原则：最小化所有的操作和Master节点的交互
系统具体的工作过程：
3.文件系统的操作
4.Master节点的操作
名称空间管理和锁
副本的位置
创建、重新复制、重新负载均衡、垃圾回收、过期失效的副本检测
5.容错和诊断
高可用性、数据完整性、诊断工具
四、总结 3.Linux文件系统工作原理：
​ 保存一个小文件
​ 保存的每一个文件都有一个元数据Metadata，其中包括filename文件信息 文件名 创建时间 文件大小 index组成文件的每一个Block的索引 关键点为1block = 1024 Byte
​ 保存一个大文件：
​ 关键点为chunk : 1chunk = 64MB =64*1024 =65536 blocks
​ 优点：减少元数据 减少流量 缺点：小文件会浪费较多空间</description>
    </item>
    
    <item>
      <title>Go语言学习总结（一）</title>
      <link>https://sin-coder.github.io/post/go/</link>
      <pubDate>Mon, 27 Jan 2020 00:53:21 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/post/go/</guid>
      <description>Go语言学习总结（一） 一、Go语言简介 1. Go语言用途 ​ 搭载Web服务器，存储集群或类似用途的巨型中央服务器的系统编程语言
​ 在高性能的分布式系统领域，Go语言比其他语言有着更高的开发效率
2. Go语言特点 ​ 自动垃圾回收、丰富的内置类型、函数多返回值、错误处理、数组安全
​ 匿名函数和闭包、类型和接口、并发编程、反射、语言交互性等
3. 设计思想 ​ 目前主流的编程思想主要有面向对象编程、面向过程编程，但是Go语言在设计的过程中吸收了一些
​ 小众的编程哲学思想，比如函数式编程思想（支持匿名函数与闭包）， 面向消息编程思想（支持 goroutine
​ 和通道），因此Go推荐使用消息而不是共享内存来进行并发编程
二、Go语言基础语法 1. 程序组成元素 （1）包声明 ​ 源文件中非注释的第一行指明这个文件属于哪个包，如package main, package main表示一个可独立执行的
​ 程序，Go程序是通过package来进行组织的，只有package名称为main的源码文件可以包含main函数
（2）引入包 ​ 导入程序所要使用的包 fmt包格式化的输入输出
​ 导入包时可以通过import关键字来单个导入，也可以同时导入多个，如：
//单个导入 import &amp;quot;fmt&amp;quot; import &amp;quot;io&amp;quot; //同时导入多个 import ( &amp;quot;fmt&amp;quot; &amp;quot;math&amp;quot; )  ​ 文件名与包名没有直接关系、同一个文件夹下只能有一个包名，否则编译报错
​ 导入包时一般为 import &amp;ldquo;项目名/包名&amp;rdquo;
​ 调用函数时则是通过PackageName.FunctionName() 来进行调用
（3）函数 ​ fun main()是程序开始执行的函数，该函数也是每一个可执行程序所必须的，每个函数后都会有{}，但是 &amp;ldquo; { &amp;ldquo;</description>
    </item>
    
    <item>
      <title>Java的异常机制</title>
      <link>https://sin-coder.github.io/post/java/</link>
      <pubDate>Mon, 27 Jan 2020 00:53:12 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/post/java/</guid>
      <description>Java中 输入输出流的继承关系总结
OutputStream &amp;mdash;》FilterOutputStream&amp;mdash;-》DataOutputStream
DataOutputStream : 将基本的Java的数据类型写入到输出流中 应用程序可以使用输入流将数据读入</description>
    </item>
    
    <item>
      <title>Github 简介</title>
      <link>https://sin-coder.github.io/post/github/</link>
      <pubDate>Mon, 27 Jan 2020 00:52:49 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/post/github/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Git学习总结</title>
      <link>https://sin-coder.github.io/post/git/</link>
      <pubDate>Mon, 27 Jan 2020 00:52:28 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/post/git/</guid>
      <description></description>
    </item>
    
    <item>
      <title>同步/异步、阻塞/非阻塞辨析</title>
      <link>https://sin-coder.github.io/post/syn/</link>
      <pubDate>Sun, 26 Jan 2020 21:35:45 +0800</pubDate>
      
      <guid>https://sin-coder.github.io/post/syn/</guid>
      <description>关键词：同步、异步、阻塞、非阻塞 相关概念：网络编程、进程与线程、I/O模型 一、问题背景 同步和异步，以及阻塞和非阻塞都是网络编程中经常遇到的概念，单看文字上的解释，确实有些晦涩难懂。接下来我们将从一个通俗的例子出发阐述它们的区别与联系
二、一个简单的例子 隔壁老王爱好茶艺，每天都会煮开水来泡茶
场景一：老王将水壶放在火上，坐在旁边等待水开 （同步阻塞）
​ 但是这样很耽搁时间，又不自由，效率很低，老王想要改变
场景二：老王将水壶放在火上，自已去隔壁了，每隔3分钟来看下水开没有 （同步非阻塞）
​ 但是这样依旧很麻烦，老王就买了一个自动报警的水壶
场景三： 老王用新买的水壶进行烧水，坐在旁边等待水开 （异步阻塞）
​ 老王便想没有必要在水壶旁边坐着啊
场景四： 老王新买的水壶放在火上，自己去隔壁了，等着报警再回来 （异步非阻塞）
​ 这种方式是最让老王省心的
小结： 同步和异步关注的焦点在于我们是否需要不断地去看水壶是否开了，同步时，需要老王不断地去轮询水壶是
​ 否开了，效率是比较低下的。而异步时，水壶告警提醒老王它开了。
​ 阻塞和非阻塞 关注的焦点在于老王是否需要坐在水壶旁边等待，在水壶旁边等待老王就是阻塞的，去做其他
​ 事的老王就是非阻塞的。
​ 这个例子可以帮助我们初步地理解同步异步、阻塞和非阻塞之间的联系和区别，但是如果详细的“追究”起来，
​ 还有许多未解释的细节
三、理论阐述 1.同步与异步 同步和异步（syn &amp;amp; asyn），描述的是在单线程中一次方法调用后，执行者是否具备主动通知的功能。同步时调用者会等到方法调用返回后才能继续后面的行为，异步时调用者不需要等到方法返回，方法执行完毕后会主动通知调用者
2.阻塞和非阻塞 阻塞和非阻塞关注是调用者是否可以执行多个任务，描述的是调用者的多个线程是否可以同时执行。阻塞时，多个线程不能同时进行；非阻塞时，多个线程可以同时进行
3.二者的区别与联系 同步和阻塞完全是在单线程和多线程这两个维度上的概念，它们之间并没有强制的联系。但是从实际的意义来看确实有一定的绑定关系，比如对于单线程来说，不管是同步还是异步，肯定是阻塞的，非阻塞只有多线程而且异步的时候才能发挥作用。
回来继续看烧水的例子，老王在烧水的同时去隔壁，也即在烧水这个线程之中，又开启了去隔壁这个线程，所以使用异步非阻塞才更加有意义</description>
    </item>
    
  </channel>
</rss>