<!doctype html>
<html lang="en-us">
  <head>
    <title>TiDB-存储原理简介 // sin-coder</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.59.1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="csuyzz" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://sin-coder.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="TiDB-存储原理简介"/>
<meta name="twitter:description" content="一、数据库最根本的功能就是把数据存下来，保存数据的方法有很多：
 最简单的就是在内存中直接构建一个数据结构（比如可以使用一个数组），保存用户发来的数据 这个方案非常简单，性能也是非常好的 但是存在很大的缺点：数据完全在内存中，一旦停机或者服务重启，数据就永远丢失 2.为了解决数据丢失的问题，可以将数据存储在非易失性的介质中，比如硬盘 这时我们可以在磁盘上创建一个文件，收到一条数据就在文件中Append一行，这样持久化存储数据 3.但是磁盘会出现坏道，我们可以做RAID,单机冗余存储； 4.但是如果机器挂了呢？我们还可以将存储改为网络存储，或者是通过硬件或者软件进行存储复制，数据安全了， 5.但是复制过程中如何保证数据的一致性呢？也就是在保证数据不丢失的情况下还要保证数据不会出现错误  所以保证数据不丢不错是最基本的要求，但是还有其他的问题：
 跨数据中心的容灾 写入速度如何提高 3.数据保存下来后是否方便读取 4.保存的数据如何修改，如何支持并发的修改？ 5.原子性地修改多条记录 二、TiKV的设计思想 1、TiKV的数据存储模型，是Key-Value的模型，并且提供有序遍历的方法，TiKV的主要特点就是 （1）.TiKV可以看做一个巨大的Map （2）.这个Map中的Key-Value是按照Key的二进制顺序有序排列的，我们可以找到某一个Key的位置 然后不断的调用Next方法以递增的顺序获取比这个Key大的Key-Value 这里的存储模型和SQL中的Table无关，TiKV是一个巨大的分布式Map  2、TiKV数据的持久化机制 TiKV没有选择直接向磁盘上写数据，而是将数据保存在RocksDB中，具体的数据落地由RocksDB完成 RocksDB是一个非常优秀的开源的单机存储引擎 至此TiKV已经有了一个高效可靠的本地存储方案 但是如何保证单机失效的情况下，数据不会丢失和出错，所以我们需要将数据复制到多台机器上，这样一台机器挂了，在其他机器上还有副本，，所以还需要一个可靠，高效且能处理副本失效的情况 3.TiKV的一致性设计思想，优化的Raft算法 Raft的主要就是一个一致性的协议，主要的功能是Leader选举、成员变更、日志复制 TiKv利用Raft来做数据复制，每条数据变更都会落地为一条Raft日志，通过Raft的日志复制功能， 将数据安全可靠地同步到Group的多数节点中 总结下TiKV的设计思想： （1）单机的RocksDB,将数据快速地存储到磁盘上 （2）通过Raft协议，将数据复制到多台机器上，防止单机失效 数据的写入是通过Raft这一层的接口写入，而不是直接写入RocksDB 通过Raft可以实现一个分布式的KV 4、Region 对于一个KV系统，将数据分散在多台机器上一般有两种方案： （1）一种是按照Key做hash,根据hash值选择对应的存储节点 （2）分Range，某一段连续的Key都保存在一个存储节点上 （TiKV解决方案） TiKV将每一个Key-Value空间分成很多段，每一段是一系列连续的Key,我们把每一段成为一个Region 每一个Region会有最大值，目前默认64Mb，每一个Region都可以用StartKey到EndKey这样一个 左开右闭的区间来描述 （3）将数据划分成Region，水平扩展和复制都是以Region为单位的 a、以Region为单位，将数据分散存储在集群的所有节点上，并且尽量保证每个节点上的服务的Region的数量差不多 数据按照Key切分成很多的Region，每个Region的数据只会保存在一个节点上面，系统会有一个组件来负责将Region 尽可能的散布在集群中的所有的节点，一方面实现了存储容量的水平扩展，同时也实现了负载均衡（不会出现某个节点有很多数据 但是其他节点机会没有数据的情况） 系统中会有一个字组件记录Region在节点上面的分布情况，即通过Key可以查到这个Key所处的Region,以及这个Region 目前实在哪个节点上 以Region为单位做Raft的复制和成员的管理 每个Region的数据会保存多个副本，每个副本可称为Replica，Replica之间是通过Raft来保持数据的一致性 一个Region的多个Replica会保存在不同的节点上，构成一个Raft Group，其中一个Replica会作为这个Group 的Leader,其他的Replica作为作为Follower。所有的读和写都会通过Leader进行，再由Leader复制给Follower 总结：以Region为单位做数据的分散和复制，一个具备分布式容灾能力的KeyValue系统就出现雏形了
4、MVCC TiKV的多版本控制 两个Client同时去修改一个Key的Value，如果没有MVCC，就需要对数据上锁，在分布式场景下，可能会导致死锁 TiKV的MVCC实现是通过在Key后面添加Version来实现的， 有了MVCC之后，TiKV的Key排列是这样的，对于同一个Key的多个版本，我们把版本号较大的放在前面，版本号较小的 放在后面，当用户通过一个Key&#43;Version来获取Value时，可以将Key和Version构造出MVCC的Key,也就是Key-Version 然后可以直接Seek（Key-Version），定位到第一个大于等于这个Key-Version的位置 5、TiKV的事务采取的是乐观锁，事务的知行不过程中不会检测写冲突，只有在提交的过程中，才会做冲突检测，冲突的双方 中比较早完成提交的会写入成功，另一方会重新尝试执行整个事务
如何理解分布式事务？ 首先应该看看事务是如何定义的： 事务提供一种机制将一个活动所涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作 只有在所有操作能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚 简单的说事务就是要么什么都不做，要么做全套，All OR Nothing"/>

    <meta property="og:title" content="TiDB-存储原理简介" />
<meta property="og:description" content="一、数据库最根本的功能就是把数据存下来，保存数据的方法有很多：
 最简单的就是在内存中直接构建一个数据结构（比如可以使用一个数组），保存用户发来的数据 这个方案非常简单，性能也是非常好的 但是存在很大的缺点：数据完全在内存中，一旦停机或者服务重启，数据就永远丢失 2.为了解决数据丢失的问题，可以将数据存储在非易失性的介质中，比如硬盘 这时我们可以在磁盘上创建一个文件，收到一条数据就在文件中Append一行，这样持久化存储数据 3.但是磁盘会出现坏道，我们可以做RAID,单机冗余存储； 4.但是如果机器挂了呢？我们还可以将存储改为网络存储，或者是通过硬件或者软件进行存储复制，数据安全了， 5.但是复制过程中如何保证数据的一致性呢？也就是在保证数据不丢失的情况下还要保证数据不会出现错误  所以保证数据不丢不错是最基本的要求，但是还有其他的问题：
 跨数据中心的容灾 写入速度如何提高 3.数据保存下来后是否方便读取 4.保存的数据如何修改，如何支持并发的修改？ 5.原子性地修改多条记录 二、TiKV的设计思想 1、TiKV的数据存储模型，是Key-Value的模型，并且提供有序遍历的方法，TiKV的主要特点就是 （1）.TiKV可以看做一个巨大的Map （2）.这个Map中的Key-Value是按照Key的二进制顺序有序排列的，我们可以找到某一个Key的位置 然后不断的调用Next方法以递增的顺序获取比这个Key大的Key-Value 这里的存储模型和SQL中的Table无关，TiKV是一个巨大的分布式Map  2、TiKV数据的持久化机制 TiKV没有选择直接向磁盘上写数据，而是将数据保存在RocksDB中，具体的数据落地由RocksDB完成 RocksDB是一个非常优秀的开源的单机存储引擎 至此TiKV已经有了一个高效可靠的本地存储方案 但是如何保证单机失效的情况下，数据不会丢失和出错，所以我们需要将数据复制到多台机器上，这样一台机器挂了，在其他机器上还有副本，，所以还需要一个可靠，高效且能处理副本失效的情况 3.TiKV的一致性设计思想，优化的Raft算法 Raft的主要就是一个一致性的协议，主要的功能是Leader选举、成员变更、日志复制 TiKv利用Raft来做数据复制，每条数据变更都会落地为一条Raft日志，通过Raft的日志复制功能， 将数据安全可靠地同步到Group的多数节点中 总结下TiKV的设计思想： （1）单机的RocksDB,将数据快速地存储到磁盘上 （2）通过Raft协议，将数据复制到多台机器上，防止单机失效 数据的写入是通过Raft这一层的接口写入，而不是直接写入RocksDB 通过Raft可以实现一个分布式的KV 4、Region 对于一个KV系统，将数据分散在多台机器上一般有两种方案： （1）一种是按照Key做hash,根据hash值选择对应的存储节点 （2）分Range，某一段连续的Key都保存在一个存储节点上 （TiKV解决方案） TiKV将每一个Key-Value空间分成很多段，每一段是一系列连续的Key,我们把每一段成为一个Region 每一个Region会有最大值，目前默认64Mb，每一个Region都可以用StartKey到EndKey这样一个 左开右闭的区间来描述 （3）将数据划分成Region，水平扩展和复制都是以Region为单位的 a、以Region为单位，将数据分散存储在集群的所有节点上，并且尽量保证每个节点上的服务的Region的数量差不多 数据按照Key切分成很多的Region，每个Region的数据只会保存在一个节点上面，系统会有一个组件来负责将Region 尽可能的散布在集群中的所有的节点，一方面实现了存储容量的水平扩展，同时也实现了负载均衡（不会出现某个节点有很多数据 但是其他节点机会没有数据的情况） 系统中会有一个字组件记录Region在节点上面的分布情况，即通过Key可以查到这个Key所处的Region,以及这个Region 目前实在哪个节点上 以Region为单位做Raft的复制和成员的管理 每个Region的数据会保存多个副本，每个副本可称为Replica，Replica之间是通过Raft来保持数据的一致性 一个Region的多个Replica会保存在不同的节点上，构成一个Raft Group，其中一个Replica会作为这个Group 的Leader,其他的Replica作为作为Follower。所有的读和写都会通过Leader进行，再由Leader复制给Follower 总结：以Region为单位做数据的分散和复制，一个具备分布式容灾能力的KeyValue系统就出现雏形了
4、MVCC TiKV的多版本控制 两个Client同时去修改一个Key的Value，如果没有MVCC，就需要对数据上锁，在分布式场景下，可能会导致死锁 TiKV的MVCC实现是通过在Key后面添加Version来实现的， 有了MVCC之后，TiKV的Key排列是这样的，对于同一个Key的多个版本，我们把版本号较大的放在前面，版本号较小的 放在后面，当用户通过一个Key&#43;Version来获取Value时，可以将Key和Version构造出MVCC的Key,也就是Key-Version 然后可以直接Seek（Key-Version），定位到第一个大于等于这个Key-Version的位置 5、TiKV的事务采取的是乐观锁，事务的知行不过程中不会检测写冲突，只有在提交的过程中，才会做冲突检测，冲突的双方 中比较早完成提交的会写入成功，另一方会重新尝试执行整个事务
如何理解分布式事务？ 首先应该看看事务是如何定义的： 事务提供一种机制将一个活动所涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作 只有在所有操作能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚 简单的说事务就是要么什么都不做，要么做全套，All OR Nothing" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sin-coder.github.io/database/tidbstorage/" />
<meta property="article:published_time" content="2020-04-24T00:53:20+08:00" />
<meta property="article:modified_time" content="2020-04-24T00:53:20+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://sin-coder.github.io"><img class="app-header-avatar" src="/cat.jpg" alt="csuyzz" /></a>
      <h1>sin-coder</h1>
      <p>I always remember that &#39;Talk is cheap,show me the code&#39;</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/sin-coder" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="mailto:csuyzz@foxmail.com" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-mail">
  <title>mail</title>
  <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>
</svg></a>
        
          <a target="_blank" href="https://cn.linkedin.com/in/csuyzz" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin">
  <title>linkedin</title>
  <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>
</svg></a>
        
          <a target="_blank" href="https://twitter.com/csuyzz1" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg></a>
        
      </div>
      <h3><a href="/" title="首页">首页</a></h3>
      <h3><a href="/category/content/" title="首页">分类目录</a></h3>
      <h3><a href="/personal/introduce/" title="首页">个人简介</a></h3>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">TiDB-存储原理简介</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Apr 24, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div><div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
          <a class="tag" href="https://sin-coder.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="tag" href="https://sin-coder.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></div></div>
    </header>
    <div class="post-content">
      <hr />

<p>一、数据库最根本的功能就是把数据存下来，保存数据的方法有很多：</p>

<ol>
<li>最简单的就是在内存中直接构建一个数据结构（比如可以使用一个数组），保存用户发来的数据
这个方案非常简单，性能也是非常好的
但是存在很大的缺点：数据完全在内存中，一旦停机或者服务重启，数据就永远丢失
2.为了解决数据丢失的问题，可以将数据存储在非易失性的介质中，比如硬盘
这时我们可以在磁盘上创建一个文件，收到一条数据就在文件中Append一行，这样持久化存储数据
3.但是磁盘会出现坏道，我们可以做RAID,单机冗余存储；
4.但是如果机器挂了呢？我们还可以将存储改为网络存储，或者是通过硬件或者软件进行存储复制，数据安全了，
5.但是复制过程中如何保证数据的一致性呢？也就是在保证数据不丢失的情况下还要保证数据不会出现错误</li>
</ol>

<p>所以保证数据不丢不错是最基本的要求，但是还有其他的问题：</p>

<ol>
<li>跨数据中心的容灾</li>
<li>写入速度如何提高
3.数据保存下来后是否方便读取
4.保存的数据如何修改，如何支持并发的修改？
5.原子性地修改多条记录
二、TiKV的设计思想
1、TiKV的数据存储模型，是Key-Value的模型，并且提供有序遍历的方法，TiKV的主要特点就是
（1）.TiKV可以看做一个巨大的Map
（2）.这个Map中的Key-Value是按照Key的二进制顺序有序排列的，我们可以找到某一个Key的位置
然后不断的调用Next方法以递增的顺序获取比这个Key大的Key-Value
这里的存储模型和SQL中的Table无关，TiKV是一个巨大的分布式Map</li>
</ol>

<p>2、TiKV数据的持久化机制
TiKV没有选择直接向磁盘上写数据，而是将数据保存在RocksDB中，具体的数据落地由RocksDB完成
RocksDB是一个非常优秀的开源的单机存储引擎
至此TiKV已经有了一个高效可靠的本地存储方案
但是如何保证单机失效的情况下，数据不会丢失和出错，所以我们需要将数据复制到多台机器上，这样一台机器挂了，在其他机器上还有副本，，所以还需要一个可靠，高效且能处理副本失效的情况
3.TiKV的一致性设计思想，优化的Raft算法
  Raft的主要就是一个一致性的协议，主要的功能是Leader选举、成员变更、日志复制
  TiKv利用Raft来做数据复制，每条数据变更都会落地为一条Raft日志，通过Raft的日志复制功能，
  将数据安全可靠地同步到Group的多数节点中
<img src="https://yunpan.oa.tencent.com/note/api/file/getImage?fileId=5e9c618c6f0b9316e255f3ed" alt="title" /></p>

<p>总结下TiKV的设计思想：
   （1）单机的RocksDB,将数据快速地存储到磁盘上
   （2）通过Raft协议，将数据复制到多台机器上，防止单机失效
        数据的写入是通过Raft这一层的接口写入，而不是直接写入RocksDB
        通过Raft可以实现一个分布式的KV
4、Region
   对于一个KV系统，将数据分散在多台机器上一般有两种方案：
   （1）一种是按照Key做hash,根据hash值选择对应的存储节点
   （2）分Range，某一段连续的Key都保存在一个存储节点上 （TiKV解决方案）
        TiKV将每一个Key-Value空间分成很多段，每一段是一系列连续的Key,我们把每一段成为一个Region
        每一个Region会有最大值，目前默认64Mb，每一个Region都可以用StartKey到EndKey这样一个
        左开右闭的区间来描述
<img src="https://yunpan.oa.tencent.com/note/api/file/getImage?fileId=5e9c65f36f0b9316e255f3f6" alt="title" /></p>

<p>（3）将数据划分成Region，水平扩展和复制都是以Region为单位的
      a、以Region为单位，将数据分散存储在集群的所有节点上，并且尽量保证每个节点上的服务的Region的数量差不多
        数据按照Key切分成很多的Region，每个Region的数据只会保存在一个节点上面，系统会有一个组件来负责将Region
        尽可能的散布在集群中的所有的节点，一方面实现了存储容量的水平扩展，同时也实现了负载均衡（不会出现某个节点有很多数据
        但是其他节点机会没有数据的情况）
        系统中会有一个字组件记录Region在节点上面的分布情况，即通过Key可以查到这个Key所处的Region,以及这个Region
        目前实在哪个节点上
      以Region为单位做Raft的复制和成员的管理
         每个Region的数据会保存多个副本，每个副本可称为Replica，Replica之间是通过Raft来保持数据的一致性
         一个Region的多个Replica会保存在不同的节点上，构成一个Raft Group，其中一个Replica会作为这个Group
         的Leader,其他的Replica作为作为Follower。所有的读和写都会通过Leader进行，再由Leader复制给Follower
     <img src="https://yunpan.oa.tencent.com/note/api/file/getImage?fileId=5e9c7c916f0b9316e255f403" alt="title" />
   总结：以Region为单位做数据的分散和复制，一个具备分布式容灾能力的KeyValue系统就出现雏形了</p>

<p>4、MVCC  TiKV的多版本控制
   两个Client同时去修改一个Key的Value，如果没有MVCC，就需要对数据上锁，在分布式场景下，可能会导致死锁
   TiKV的MVCC实现是通过在Key后面添加Version来实现的，
<img src="https://yunpan.oa.tencent.com/note/api/file/getImage?fileId=5e9db7516f0b9316e25618bd" alt="title" />
   有了MVCC之后，TiKV的Key排列是这样的，对于同一个Key的多个版本，我们把版本号较大的放在前面，版本号较小的
   放在后面，当用户通过一个Key+Version来获取Value时，可以将Key和Version构造出MVCC的Key,也就是Key-Version
   然后可以直接Seek（Key-Version），定位到第一个大于等于这个Key-Version的位置
5、TiKV的事务采取的是乐观锁，事务的知行不过程中不会检测写冲突，只有在提交的过程中，才会做冲突检测，冲突的双方
   中比较早完成提交的会写入成功，另一方会重新尝试执行整个事务</p>

<p><strong>如何理解分布式事务？</strong>
首先应该看看事务是如何定义的：
事务提供一种机制将一个活动所涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作
只有在所有操作能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚
简单的说事务就是要么什么都不做，要么做全套，All OR Nothing</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>
<script src="https://utteranc.es/client.js"
        repo="sin-coder/hugocomments"
        issue-term="pathname"
        theme="github-dark"  
        crossorigin="anonymous"
        async>
</script>

    </main>
  </body>
</html>
